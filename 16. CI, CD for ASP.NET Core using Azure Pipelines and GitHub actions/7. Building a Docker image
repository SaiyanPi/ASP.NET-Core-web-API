Building a Docker image:

- Docker provides a set of commands that can be used to build, run, and manage Docker images and containers.
- To build a Docker image, go to the root directory of the ASP.NET Core project we created earlier, then
    run the following command:

    syntax: docker build -t <image_name>:<tag> -f<path_to_dockerfile></path_to_dockerfile> .

        -> the -t option is used to tag the image with a name.
        -> . at the end means the current directory.
        -> for eg, if our Dockerfile is renamed to "Dockerfile.dev" and is in the current directory, we
            would run:

            cmd: docker build -t whatevername:whatevertagname -f Dockerfile.dev .

        -> if we have renamed Dockerfile named "MyDockerfile" inside the Docker folder inside the current
            directory, we would run:

            cmd: docker build -t whatevername:whatevertagname -f Docker/MyDockerfile .

        -> In our case we haven't changed Dockerfile name and is in the current directory so we need to run

            cmd: docker build -t basicwebapiimage:demo .

            we have given our image a tag named demo. if we don't give any tag, automatically 'latest' will
            be added as default.


    * The output shows that Docker is building the image layer by layer. Each instruction in the Dockerfile
        will create a layer in the image and add more content on top of the previous layer.
    * The layers are cached, so if a layer has not changed, it will not be rebuilt for the next build. But
        if a layer has changed(for example, if we update the source code), then the layer that copies the
        source code will be rebuilt, and all the layers after that will be affected and need to be rebuilt
        as well.
------------------------------------------------------------------------------------------------------------

- Let's go back to previous section and let us review the default Dockerfile generated by VS 2022.

    // omitted
    RUN dotnet restore "./BasicWebApiDemo.csproj"
    COPY . .
    // omitted

    -> Why does it copy all the files after running the dotnet restore command?
        It is because if we only update the source code but the NuGet package have not changed, then the
        'dotnet restore' command will not be executed again as the layer is cached. This can improve the
        build performance . However, if we update the NuGet packages, meaning the .csproj file has changed,
        then the dotnet restore command will be executed again.

- Here are some tips for writing Dockerfiles:
    i) Consider the order of layers. Layers that are less likely to change should be placed before layers
        that are more likely to change.
    ii) Keep layers small as much as possible. Do not copy unnecessary files. You can configure the
        .dockerignore file to exclude files or directories from the build context.
        If you use VS 2022 to create the Dockerfile, it will generate a .dockerignore file for you.
        Aletrnatively, you can manually create a text file named .dockerignore and then edit it.
        The following code snippet shows an example .dockerignore file.

            # comment
            */temp*
            */*/temp*
            temp?
        
        This file cause the following build behaviour:

        Rule                                                 Behaviour
        ---------------------------------------------------------------------------------------------------
        # comment                                            ignore

        */temp*                                             excludes files and directories whose names
                                                            start with temp in any immediate subdirectory
                                                            of the root. for eg, the plain file
                                                            /somedir/temporary.txt is excluded, as is the
                                                            directory /somedir/temp.

        */*/temp*                                           excludes files and directories starting with temp
                                                            from any subdirectory that is 2 levels below the
                                                            root. for eg, /somedir/subdir/temporary.txt is
                                                            excluded.

        temp?                                               exclude files and directories in the root directory
                                                            whose names are a one-character extension of temp.
                                                            for eg, /tempa and /tempb are excluded.

        for more information about the .dockerignore file https://docs.docker.com/reference/dockerfile/#dockerignore-file

    iii) keep as few layers as possible. for eg, to host an ASP.NET Core application, we can reduce the
        number of layers by using the 'mcr.microsoft.com/dotnet/aspnet' image. This image contains the
        ASP.NET Core runtime already, eliminating the need to install the SDK in the container. You can
        also combine commands into a single RUN instruction.

    iv) use multi-stage builds. multi-stage builds allow us to use multiple FROM instructions in a
        Dockerfile. Each FROM instruction can be used to create a new image. The final image will only
        contain the layers from the last FROM instruction. This can reduce the size of the final image.
        for eg, we can use the 'mcr.microsoft.com/dotnet/sdk' image to build the application and then use 
        the 'mcr.microsoft.com/dotnet/aspnet' image to runthe application. This way, the final image will
        only contain the ASP.NET Core runtime, and it will not contain the SDK, which is not needed for
        running the application.
        To learn more about the multi-stage builds, https://docs.docker.com/build/building/multi-stage/

- For more information on optimizing Docker builds, please refer to the official documentation
    here: https://docs.docker.com/build/cache/.
-------------------------------------------------------------------------------------------------------------------

- to list all Docker images on our machine:

    cmd: docker images
    o/p: 
        REPOSITORY                        TAG       IMAGE ID       CREATED         SIZE
        saiyanimage                       demo      975b567d128a   4 minutes ago   325MB

    -> Each image has a TAG value and an IMAGE ID value. The TAG value is a human-readable name for the
        image. By default, the tag is latest. We can specify a different tag when building the image.

- to remove an image:

    syntax: docker rmi <container name or ID>
    eg: docker rmi saiyanimage:test or docker rmi 975b567d128a

    -> Note that if the image is used by a container, you will need to stop the container first before
        removing the image.

We now have a Docker image for our ASP.NET Core application. All the necessary dependencies are included
in the image. Next, let us run the Docker image.