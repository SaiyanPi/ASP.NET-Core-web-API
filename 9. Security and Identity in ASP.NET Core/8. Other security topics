# Always use Hypertext Transfer Protocol Secure (HTTPS):

- HTTPS is a protocol that provides secure communication between a client and a server. It is a
    combination of the HTTP and Secure Sockets Layer/Transport Layer Security (SSL/TLS) protocols.
    HTTPS is used to encrypt communication between the client and the server, ensuring that sensitive
    data transmitted over the internet is secure and cannot be intercepted by unauthorized third parties.
    Google Chrome and other modern browsers will display a warning if you try to access a website that
    does not use HTTPS. Therefore, it is very important to use HTTPS for all your web applications.
- The default ASP.NET Core web API template can use both HTTP and HTTPS. It is recommended
    to use HTTPS only. So, we need to configure the project to redirect all HTTP requests to HTTPS.
- To do that, we need to add the following code to the Program.cs file:
    
    app.UseHttpsRedirection();

    -> This code applies the UseHttpsRedirection middleware to redirect HTTP requests to HTTPS.
- When you run the application locally, ASP.NET Core will automatically generate a self-signed certificate
and use it to encrypt communication. However, when you deploy the application to a production
environment, you need to use a certificate issued by a trusted certificate authority (CA), such as
DigiCert, Comodo, GeoTrust, and so on.

-----------------------------------------------------------------------------------------------------------


# Implementing two-factor authentication (2FA):

- Besides the common username and password, 2FA adds an extra layer of security by requiring users
    to provide a second authentication factor, such as a code sent to their mobile phone or
    authenticator app, fingerprint, face recognition, and so on. This makes it harder for hackers to
    gain access to user accounts. Even if the hacker gets the user’s password, they still cannot get
    the second factor. 2FA is widely used in banking and financial services to protect users’
    sensitive information.
- Multi-factor authentication (MFA) is a superset of 2FA. It requires users to provide more than two
    factors to verify their identity. There are two types of MFA:

    a) MFA Time-based One-Time Password (TOTP):
    MFA TOTP is a type of MFA that requires users to provide a code generated by an authenticator app
    (such as Google Authenticator or Microsoft Authenticator). The code is valid for a short period,
    usually 30 seconds. After the code expires, the user needs to generate a new code. This type of
    MFA is widely used in banking and financial services. If you use a bank app, you might have seen
    this type of MFA. It requires the server and authenticator app to have an accurate time.

    b) MFA Fast Identity Online 2 (FIDO2):
    MFA FIDO2 is a type of MFA that requires users to authenticate using a hardware key, such as a
    USB key or a biometric device (such as a fingerprint scanner). It has become more popular in
    recent years. However, ASP.NET Core does not supportFIDO2 directly yet.

    c) MFA SMS: 
    MFA SMS is no longer recommended because there are many security issues with SMS

- To learn more about MFA, please refer to https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa.


--------------------------------------------------------------------------------------------------------------------


# Implementing rate-limiting:

- discussed in chapter 5/2.3

------------------------------------------------------------------------------------------------------------


# Using model validation:

- Model validation is a security mechanism that prevents malicious users from sending invalid data
    to the server. We should always validate the data sent by the client.
    For example, we expect a property in the model to be an integer, but what if the client sends
    a string? The application should be able to handle this situation and reject the request directly
    before executing any business logic.
- ASP.NET Core provides a built-in model binding and model validation mechanism.
    Model binding is used to convert the data sent by the client to the corresponding model.
    The data sent by the client can be in different formats, such as JSON, XML, form fields, or query
    strings. Model validation is used to check whether the data sent by the client is valid.

    [HttpPost("register")]
    public async Task<IActionResult> Register([FromBody] AddOrUpdateAppUserModel model)
    {
        // Check if the model is valid
        if (ModelState.IsValid)
        {
            // omitted
        }
        return BadRequest(ModelState);
    }
    -> The ModelState.IsValid property represents whether the model is valid.
    -> So, how does ASP.NET Core validate the model?

    public class AddOrUpdateAppUserModel
    {
        [Required(ErrorMessage = "User name is required")]
        public string UserName { get; set; } = string.Empty;

        [EmailAddress]
        [Required(ErrorMessage = "Email is required")]
        public string Email { get; set; } = string.Empty;
        
        [Required(ErrorMessage = "Password is required")]
        public string Password { get; set; } = string.Empty;
    }
    -> We use the validation attributes to specify the validation rules. For example, Required is a
        built-in attribute annotation that specifies that the property is required. Here are some of
        the most commonly used ones besides Required:

        CreditCard => This specifies that the property must be a valid credit card number

        EmailAddress => This specifies that the property must be a valid email address

        Phone => This specifies that the property must be a valid phone number

        Range => This specifies that the property must be within a specified range

        RegularExpression => This specifies that the property must match a specified regular expression

        StringLength => This specifies that the property must be a string with a specified length

        Url => This specifies that the property must be a valid URL

        Compare => This specifies that the property must be the same as another property

- CREATING CUSTOM ATTRIBUTE:

    public class AdultAttribute : ValidationAttribute
    {
        public string GetErrorMessage() => $"You must be at least 18 years old to register.";
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            var birthDate = (DateTime)value;
            var age = DateTime.Now.Year - birthDate.Year;
            if (DateTime.Now.Month < birthDate.Month || 
                (DateTime.Now.Month == birthDate.Month && DateTime.Now.Day < birthDate.Day))
            {
                age--;
            }
            if (age < 18)
            {
                return new ValidationResult(GetErrorMessage());
            }
            return ValidationResult.Success;
        }
    }

    Then we can use Adult attribute in the model as:

    public class AddOrUpdateAppUserModel
    {
        // Omitted for brevity
        [Required(ErrorMessage = "Birthday is required")]
        [Adult]
        public DateTime Birthday { get; set; }
    }

- we can also manually validate the model in the controller.
    for eg, we can check whether the user's email is unique as:
    
    [HttpPost("register")]
    public async Task<IActionResult> Register([FromBody] AddOrUpdateAppUserModel model)
    {
         // Check if the email is unique
        if (await userManager.FindByEmailAsync(model.Email) != null)
        {
            ModelState.AddModelError("Email", "Email already exists");
            return BadRequest(ModelState);
        }
        if (ModelState.IsValid)
        {
           // omitted
        }
        return BadRequest(ModelState);
    }

    -> In the preceding code, we use the AddModelError() method to add a validation error to the
        model. The ModelState.IsValid property will return false if there is any validation error.

------------------------------------------------------------------------------------------------------------


# Using parameterized queries:

- We explained how to use EF Core to execute SQL queries in previous chapter 8.
- Generally, if we use LINQ to query data, EF Core will generate parameterized queries for you.
    However, you need to take care of SQL injection attacks when you use the following methods:
    • FromSqlRaw()
    • SqlQeuryRaw()
    • ExecuteSqlRaw()
- These methods allow you to execute raw SQL queries without sanitizing the input. So, please make
    sure you sanitize the query statements before executing them.

--------------------------------------------------------------------------------------------------------------


# Using data protection:

- Data protection is a security mechanism that prevents malicious users from accessing sensitive data.
    For example, if you store the user’s password in the database, you should encrypt it before storing
    it. Another example is the user’s credit card number, which should also be encrypted before it is
    stored.
- The reason for this is that if the database is compromised, the attacker can easily access the user’s
    sensitive data. In other words, the database is not trusted, just like the client.
- see more https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction?view=aspnetcore-9.0

-----------------------------------------------------------------------------------------------------------------


# Keeping secrets safe:

- Secrets are sensitive data that should not be exposed to the public. In our applications, we may have
    many secrets, such as the database connection string, the API keys, the client secrets, and so on.
-  In the previous chapters, we often stored them in the appsettings.json file. However, we need
        to emphasize that this is not a good practice. These secrets should be stored in a safe place,
        such as Azure Key Vault, AWS Secrets Manager, or kube-secrets. Never upload them to the source
        code repository
    
------------------------------------------------------------------------------------------------------------------


# Keeping the framework up to date:

- The .NET Core framework is an open-source project. It is constantly being updated. We should always
    keep the framework up to date, including the NuGet packages. Note the life cycle of the .NET Core
    framework. Use the latest version of the framework as much as possible. If you are using an older
    version, you should consider upgrading it.

-----------------------------------------------------------------------------------------------------------------------


# Checking the Open Web Application Security Project (OWASP) Top 10:

- OWASP is a nonprofit organization that provides information about web application security. It
    publishes a list of the most common web application security risks, which is called the OWASP Top
    10. You can find the OWASP Top 10 here: https://owasp.org/www-project-top-ten/.
    You should check the list regularly to make sure your application is not vulnerable to any of the risks.
    
- Also, OWASP provides a free resource called DotNet Security Cheat Sheet, where you can find the best
    practices for securing .NET Core applications. You can find it here: https://cheatsheetseries.
    owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html.