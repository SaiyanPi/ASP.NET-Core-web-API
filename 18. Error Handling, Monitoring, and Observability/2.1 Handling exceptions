Handling Exceptions:

- MyWebApiDemo sample application has a controller named UsersController, which has an action to get a
    user by their user ID. This action looks as follows:

    [HttpGet("{id:int}")]
    public ActionResult<User> Get(int id)
    {
        var user = Users.First(u => u.Id == id);
        if (user == null)
        {
            return NotFound();
        }
    }

- It is not advisable to use First in this instance as it will result in an exception being thrown if the 
    user is not found in the collection. To illustrate how to handle exceptions in the application, we will 
    use this example.
- dotnet watch run the application and  send a GET request to the https://localhost:5001/users/100 
    endpoint. Let's test it in the swagger UI directly. The application will return a 500 error because 
    no user with an ID of 100 will be found.

- Regardless of whether the application is running in the development environment, the response 
    body contains the stack trace. We should never show the stack trace for the production environment. 
    Additionally, the response body is not a valid JSON payload, making it difficult for the client to
    parse it.
- ASP.NET Core provides a built-in exception handling middleware to handle exceptions and return 
    an error payload.
- The exception handling middleware can return a valid JSON payload to the client. 
    This kind of JSON payload for error and exceptions is called Problem Details and is defined in 
    RFC7807: https://datatracker.ietf.org/doc/html/rfc7807

- A problem details object can have the following properties:

    • type: A URI reference that’s used to identify the problem type. This reference provides helpful 
            documentation in a human-readable format, which can assist clients in understanding the error.
   
    • title: A summary that describes the problem’s type in a human-readable format.
   
    • status: An HTTP status code generated by the original server to indicate the status of 
                the problem.
   
    • detail: A human-readable description of the problem.
   
    • instance: A URI reference that provides a specific occurrence of the problem, allowing for 
                a more precise understanding of the issue.

- The client can parse the problem details object and display a user-friendly error message. This object 
    can be extended to include additional information about the error, though the existing properties 
    should be sufficient for most cases.

------------------------------------------------------------------------------------------------------------

1) To use the exception handling middleware, we need to create a controller to show the problem details.
    Create a new controller named ErrorController and add the following code:

    [ApiController]
    [ApiExplorerSettings(IgnoreApi = true)]
    public class ErrorController(ILogger<ErrorController> logger) : ControllerBase
    {
        [Route("/error-development")]
        public IActionResult HandleErrorDevelopment([FromServices] IHostEnvironment hostEnvironment)
        {
            if (!hostEnvironment.IsDevelopment())
            {
                return NotFound();
            }

            var exceptionHandlerFeature = HttpContext.Features.Get<IExceptionHandlerFeature>()!;

            logger.LogError(exceptionHandlerFeature.Error, exceptionHandlerFeature.Error.Message);

            return Problem(
                detail: exceptionHandlerFeature.Error.StackTrace,
                title: exceptionHandlerFeature.Error.Message);
        }

        [Route("/error")]
        public IActionResult HandleError()
        {
            var exceptionHandlerFeature = HttpContext.Features.Get<IExceptionHandlerFeature>()!;
            logger.LogError(exceptionHandlerFeature.Error, exceptionHandlerFeature.Error.Message);
            return Problem();
        }
    }

    a) The controller is marked with the [ApiExplorerSettings(IgnoreApi = true)] attribute.
        This attribute is used to hide this endpoint from the OpenAPI specification and Swagger UI.
    b) The controller has two actions. The first action is used to show a detailed error message in the 
        development environment, so it provides the route /error-development that shows the 
        stack trace of the exception. The second action is used to show a generic error message in the 
        production environment, so it provides the /error route that has no additional information 
        about the exception.
    c) In the actions, we use the IExceptionHandlerFeature interface to get the exception information.
        The IExceptionHandlerFeature interface is a feature containing the exception of the original
        request to be examined by an exception handler. We can log the exception information or return
        it to the client.

2) Next, we need to register the exception handling middleware in the application. Open the Program.cs
    file and call the UseExceptionHandler method to add the exception handling middleware:

        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
            app.UseExceptionHandler("/error-development");
        }
        else
        {
            app.UseExceptionHandler("/error");
        }

        -> For the development environment, we can use the /error-development endpoint to show the 
            detailed error message.
        -> For the production environment, we can use the /error endpoint to show the generic error
            message. It is a good practice to hide the stack trace in the production environment.
        -> Run the application and send a GET request to the https://localhost:5001/users/100. 
            The response body now contains a problem details JSON payload. It also contains the stack trace of the 
            exception for troubleshooting in the development environment. The client can parse the response body 
            and display a user-friendly error message. (see exception-handling-middleware-use-result.png)
        ->  Meanwhile, the response headers contain the ContentType header with a value of 
            application/problem+json. This indicates that the response body is a problem details JSON
            payload
        
        -> If we run the application in the production environment, the reponse body will not contain the
            stack trace of the exception. (see no-stack-trace-in-production.png)