Adding Mutations:

-> In the previous section, we learned how to create GraphQL API usingHotChocolate. We added a query
    root type to query data. In this section we will discuss how to modify data using mutations.
-> Mutations are used to modify data in GraphQL. A mutation consists of 3 parts:

    • Input:
        The input is the data that will be used to modify the data. It is named with the Input
        suffix following the convention, such as AddTeacherInput.

    • Payload:
        The payload is the data that will be returned after the mutation is executed. It is named
        with the Payload suffix following the convention, such as AddTeacherPayload.

    • Mutation:
        The mutation is the operation that will be executed. It is named as verb + noun following
        the convention, such as AddTeacherAsync.

-> Let's add a mutation to create a new teacher. Follow the steps below:

1) Create an AddTeacherInput class in the GraphQL/Mutations folder as:

    public record AddTeacherInput(
    string FirstName,
    string LastName,
    string Email,
    string? Phone,
    string? Bio);

    * The AddTeacherInput class is a record type that defines the input data for the AddTeacherAsync
        mutation.
    * The Id property is not included in the input data because it will be generated by the code.

2) Add an AddTeacherPayload class in the GraphQL/Mutations folder as:

    public class AddTeacherPayload
    {
        public Teacher Teacher { get; }
        public AddTeacherPayload(Teacher teacher)
        {
            Teacher = teacher;
        }
    }

    * It has a Teacher property of the Teacher type

3) Next, we need to add the actual mutation to execute the operation. Add the Mutation class as:

    public class Mutation
    {
        public async Task<AddTeacherPayload> AddTeacherAsync(
        AddTeacherInput input, [Service] AppDbContext context)
        {
            var teacher = new Teacher
            {
                Id = Guid.NewGuid(),
                FirstName = input.FirstName,
                LastName = input.LastName,
                Email = input.Email,
                Phone = input.Phone,
                Bio = input.Bio
            };
            context.Teachers.Add(teacher);
            await context.SaveChangesAsync();
            return new AddTeacherPayload(teacher);
        }
    }

    * Mutation class has one method named AddTeacherAsync() which takes an AddTeacherInput object
        as the input data and returns an AddTeacherPayload object.
    * AddTeacherAsync() method creates a new Teacher object and adds it to the database.
    * AddTeacherPayload object that contains the newly created Teacher object.

4) Next, we need to register the mutation in the Program.cs file. Add the AddMutationType method
    after the AddQueryType() method, as follows:

    builder.Services
        .AddGraphQLServer()
        .AddQueryType<Query>()
        .AddMutationType<Mutation>();

5) Run the project using dotnet run and open the GraphQL IDE.
    Check the schema definition and you should see the following mutation:

        type Mutation {
            addTeacher(input: AddTeacherInput!): AddTeacherPayload! @cost(weight: "10")
        }
        input AddTeacherInput {
            firstName: String!
            lastName: String!
            email: String!
            phone: String
            bio: String
        }
        type AddTeacherPayload {
            teacher: Teacher!
        }   

    * The preceding schema defines a mutation named addTeacher, which reflects the types and methods
        we defined in the Mutation class.
    * Note that the AddTeacherInput type is an input type, so it uses the input keyword instead of
        type.
        
6) Click the Create Document button to create a new query. You can use the following mutation  to create
    a new teacher:

        mutation addTeacher {
            addTeacher(
                input: {
                firstName: "John"
                lastName: "Smith"
                email: "john.smith@sampleschool.com"
                phone: "1234567890"
                bio: "John Smith is a math teacher."
                }
            ) {
                teacher {
                id
                }
            }
        }

        error:  {
                "errors": [
                    {
                    "message": "Unexpected Execution Error",
                    "locations": [
                        {
                        "line": 2,
                        "column": 3
                        }
                    ],
                    "path": [
                        "addTeacher"
                    ]
                    }
                ],
                "data": null
                }
        
        console: ---> Microsoft.Data.SqlClient.SqlException (0x80131904): The INSERT statement 
                        conflicted with the FOREIGN KEY constraint  "FK_Teachers_Departments_DepartmentId". 
                        The conflict occurred in database "Chapter14GraphQlDemoDb", table "dbo.Departments",
                        column 'Id'.
        
        * This is because we have a foreign key 'DepartmentId' in the Teacher class. Department is a Principal
            entity and Teacher is a dependent entity. So we also need to assign a DepartmentId when creating
            new Teacher. Let's add the DepartmentId property to our mutation as:

            (AddTeacherInput class)

                public record AddTeacherInput(
                string FirstName,
                string LastName,
                string Email,
                string? Phone,
                string? Bio,
                Guid? DepartmentId);
            
            (Mutation class)

                public class Mutation
                {
                    public async Task<AddTeacherPayload> AddTeacherAsync(
                    AddTeacherInput input, [Service] AppDbContext context)
                    {
                        var teacher = new Teacher
                        {
                            Id = Guid.NewGuid(),
                            // omitted
                            Bio = input.Bio,
                            DepartmentId = (Guid)input.DepartmentId,
                        };
                        context.Teachers.Add(teacher);
                        await context.SaveChangesAsync();
                        return new AddTeacherPayload(teacher);
                    }
                }
        
    Now, dotnet run the application and check the schema definition. DepartmentId property can be seen in
        a input AddTeacherInput as:

        input AddTeacherInput {
            firstName: String!
            lastName: String!
            email: String!
            phone: String
            bio: String
            departmentId: UUID
        }

    Finally, we can use the following mutation to create a new teacher.

        mutation addTeacher {
            addTeacher(
                input: {
                firstName: "John",
                lastName: "Smith",
                email: "john.smith@sampleschool.com",
                phone: "1234567890",
                bio: "John Smith is a math teacher.",
                departmentId: "00000000-0000-0000-0000-000000000001"
                
                }
            )
            {
                teacher {
                id
                lastName
                }
            }
        }

    Response:   {
                    "data": {
                        "addTeacher": {
                        "teacher": {
                            "id": "268a15c2-f42a-4ec6-9ad6-dd3cb62e1706",
                            "lastName": "Smith"
                        }
                        }
                    }
                }
    * this shows that the new teacher with id 68a15c2-f42a-4ec6-9ad6-dd3cb62e1706 has been created.